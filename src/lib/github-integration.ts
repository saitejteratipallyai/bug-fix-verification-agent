import * as path from 'path';
import { execSync } from 'child_process';
import { AgentConfig } from './config';

export interface PRInfo {
  number: number;
  title: string;
  body: string;
  labels: string[];
  changedFiles: string[];
  isBugFix: boolean;
}

export function getChangedFiles(config: AgentConfig, baseBranch: string = 'main'): string[] {
  try {
    const output = execSync(`git diff --name-only ${baseBranch}...HEAD`, {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
    });
    return output
      .split('\n')
      .map(f => f.trim())
      .filter(f => f.length > 0);
  } catch {
    // Fallback: get unstaged + staged changes
    try {
      const output = execSync('git diff --name-only HEAD', {
        cwd: config.workspaceRoot,
        encoding: 'utf-8',
      });
      return output
        .split('\n')
        .map(f => f.trim())
        .filter(f => f.length > 0);
    } catch {
      return [];
    }
  }
}

export function getStagedFiles(config: AgentConfig): string[] {
  try {
    const output = execSync('git diff --cached --name-only', {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
    });
    return output
      .split('\n')
      .map(f => f.trim())
      .filter(f => f.length > 0);
  } catch {
    return [];
  }
}

export function getCurrentBranch(config: AgentConfig): string {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD', {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
    }).trim();
  } catch {
    return 'unknown';
  }
}

export function extractBugDescription(prBody: string): string {
  // Try to extract from common PR template patterns
  const patterns = [
    /## Bug Description\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i,
    /## Description\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i,
    /## What was the bug\?\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i,
    /Bug:\s*(.+)/i,
    /Fix(?:es|ed)?:\s*(.+)/i,
    /Resolves?:\s*(.+)/i,
  ];

  for (const pattern of patterns) {
    const match = prBody.match(pattern);
    if (match?.[1]) {
      return match[1].trim();
    }
  }

  // Return first paragraph as fallback
  const firstParagraph = prBody.split('\n\n')[0];
  return firstParagraph?.trim() || prBody.trim();
}

export function isBugFixPR(title: string, labels: string[]): boolean {
  const bugLabels = ['bug', 'bugfix', 'bug-fix', 'fix', 'hotfix'];
  const bugPrefixes = ['fix:', 'bugfix:', 'bug:', 'hotfix:', 'fix(', 'bug('];

  const hasLabel = labels.some(l => bugLabels.includes(l.toLowerCase()));
  const hasPrefix = bugPrefixes.some(p => title.toLowerCase().startsWith(p));

  return hasLabel || hasPrefix;
}

export function formatPRComment(
  bugDescription: string,
  passed: boolean,
  visualAssessment: string | undefined,
  testDuration: number,
  hasArtifacts: boolean
): string {
  const status = passed ? 'âœ… Passed' : 'âŒ Failed';
  const emoji = passed ? 'ğŸ¬' : 'ğŸš¨';

  let comment = `## ${emoji} Bug Fix Verification

**Status:** ${status}
**Bug:** ${bugDescription}
**Duration:** ${(testDuration / 1000).toFixed(1)}s
`;

  if (visualAssessment) {
    comment += `
### AI Visual Analysis
${visualAssessment}
`;
  }

  if (hasArtifacts) {
    comment += `
### Artifacts
ğŸ“¹ Video recording and trace available in workflow artifacts.
`;
  }

  comment += `
---
*Generated by [Bug Fix Verification Agent](https://marketplace.visualstudio.com/items?itemName=bug-fix-agent.bug-fix-verification-agent)*`;

  return comment;
}
