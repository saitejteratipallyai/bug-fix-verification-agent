import * as path from 'path';
import * as fs from 'fs';
import { execSync } from 'child_process';
import { AgentConfig } from './config';
import { FixResult } from './bug-fixer';
import { VerificationResult } from './verification-pipeline';

export interface PRInfo {
  number: number;
  title: string;
  body: string;
  labels: string[];
  changedFiles: string[];
  isBugFix: boolean;
}

export function getChangedFiles(config: AgentConfig, baseBranch: string = 'main'): string[] {
  try {
    const output = execSync(`git diff --name-only ${baseBranch}...HEAD`, {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
    });
    return output
      .split('\n')
      .map(f => f.trim())
      .filter(f => f.length > 0);
  } catch {
    // Fallback: get unstaged + staged changes
    try {
      const output = execSync('git diff --name-only HEAD', {
        cwd: config.workspaceRoot,
        encoding: 'utf-8',
      });
      return output
        .split('\n')
        .map(f => f.trim())
        .filter(f => f.length > 0);
    } catch {
      return [];
    }
  }
}

export function getStagedFiles(config: AgentConfig): string[] {
  try {
    const output = execSync('git diff --cached --name-only', {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
    });
    return output
      .split('\n')
      .map(f => f.trim())
      .filter(f => f.length > 0);
  } catch {
    return [];
  }
}

export function getCurrentBranch(config: AgentConfig): string {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD', {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
    }).trim();
  } catch {
    return 'unknown';
  }
}

export function extractBugDescription(prBody: string): string {
  // Try to extract from common PR template patterns
  const patterns = [
    /## Bug Description\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i,
    /## Description\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i,
    /## What was the bug\?\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i,
    /Bug:\s*(.+)/i,
    /Fix(?:es|ed)?:\s*(.+)/i,
    /Resolves?:\s*(.+)/i,
  ];

  for (const pattern of patterns) {
    const match = prBody.match(pattern);
    if (match?.[1]) {
      return match[1].trim();
    }
  }

  // Return first paragraph as fallback
  const firstParagraph = prBody.split('\n\n')[0];
  return firstParagraph?.trim() || prBody.trim();
}

export function isBugFixPR(title: string, labels: string[]): boolean {
  const bugLabels = ['bug', 'bugfix', 'bug-fix', 'fix', 'hotfix'];
  const bugPrefixes = ['fix:', 'bugfix:', 'bug:', 'hotfix:', 'fix(', 'bug('];

  const hasLabel = labels.some(l => bugLabels.includes(l.toLowerCase()));
  const hasPrefix = bugPrefixes.some(p => title.toLowerCase().startsWith(p));

  return hasLabel || hasPrefix;
}

export function formatPRComment(
  bugDescription: string,
  passed: boolean,
  visualAssessment: string | undefined,
  testDuration: number,
  hasArtifacts: boolean
): string {
  const status = passed ? 'âœ… Passed' : 'âŒ Failed';
  const emoji = passed ? 'ðŸŽ¬' : 'ðŸš¨';

  let comment = `## ${emoji} Bug Fix Verification

**Status:** ${status}
**Bug:** ${bugDescription}
**Duration:** ${(testDuration / 1000).toFixed(1)}s
`;

  if (visualAssessment) {
    comment += `
### AI Visual Analysis
${visualAssessment}
`;
  }

  if (hasArtifacts) {
    comment += `
### Artifacts
ðŸ“¹ Video recording and trace available in workflow artifacts.
`;
  }

  comment += `
---
*Generated by [Bug Fix Verification Agent](https://marketplace.visualstudio.com/items?itemName=bug-fix-agent.bug-fix-verification-agent)*`;

  return comment;
}

// â”€â”€â”€ PR Creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export interface PRCreationResult {
  prUrl: string;
  prNumber: number;
  branchName: string;
}

export type PRProgressCallback = (message: string) => void;

/**
 * Check if the workspace is a git repo
 */
export function isGitRepo(config: AgentConfig): boolean {
  try {
    execSync('git rev-parse --is-inside-work-tree', {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
      stdio: 'pipe',
    });
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if `gh` CLI is installed and authenticated
 */
export function isGhCliAvailable(config: AgentConfig): boolean {
  try {
    execSync('gh auth status', {
      cwd: config.workspaceRoot,
      encoding: 'utf-8',
      stdio: 'pipe',
    });
    return true;
  } catch {
    return false;
  }
}

/**
 * Convert a video file to GIF using ffmpeg. Returns the GIF path or null.
 */
function convertVideoToGif(videoPath: string, outputDir: string): string | null {
  try {
    const gifPath = path.join(outputDir, 'test-verification.gif');
    execSync(
      `ffmpeg -y -i "${videoPath}" -vf "fps=10,scale=800:-1:flags=lanczos" -loop 0 "${gifPath}"`,
      { encoding: 'utf-8', stdio: 'pipe', timeout: 30000 }
    );
    if (fs.existsSync(gifPath)) {
      return gifPath;
    }
  } catch { /* ffmpeg not available or conversion failed */ }
  return null;
}

/**
 * Get the GitHub repo slug (owner/repo) using gh CLI.
 */
function getRepoSlug(cwd: string): string | null {
  try {
    return execSync('gh repo view --json nameWithOwner -q .nameWithOwner', {
      cwd, encoding: 'utf-8', stdio: 'pipe',
    }).trim() || null;
  } catch {
    return null;
  }
}

/**
 * Create a GitHub Pull Request after a successful bug fix.
 * Steps: create branch â†’ prepare evidence â†’ commit fix + evidence â†’ push â†’ create PR â†’ upload evidence for inline rendering
 */
export async function createPullRequest(
  config: AgentConfig,
  bugDescription: string,
  fix: FixResult,
  verification: VerificationResult | null,
  onProgress?: PRProgressCallback
): Promise<PRCreationResult> {
  const cwd = config.workspaceRoot;

  // Generate branch name from bug description
  const sanitized = bugDescription
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, '-')
    .substring(0, 40);
  const timestamp = Date.now();
  const branchName = `bugfix/${sanitized}-${timestamp}`;

  // â”€â”€â”€ Prepare evidence files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  onProgress?.('Preparing evidence files...');
  const evidenceDir = path.join(cwd, 'evidence');
  if (!fs.existsSync(evidenceDir)) {
    fs.mkdirSync(evidenceDir, { recursive: true });
  }

  let gifPath: string | null = null;
  let screenshotEvidencePath: string | null = null;

  if (verification) {
    // Convert first video to GIF
    if (verification.testResult.videos.length > 0) {
      onProgress?.('Converting test video to GIF...');
      gifPath = convertVideoToGif(verification.testResult.videos[0], evidenceDir);
      if (gifPath) {
        const gifSize = (fs.statSync(gifPath).size / 1024).toFixed(0);
        onProgress?.(`GIF created (${gifSize} KB)`);
      }
    }

    // Copy first screenshot
    if (verification.testResult.screenshots.length > 0) {
      const srcScreenshot = verification.testResult.screenshots[0];
      if (fs.existsSync(srcScreenshot)) {
        screenshotEvidencePath = path.join(evidenceDir, 'test-result-screenshot.png');
        fs.copyFileSync(srcScreenshot, screenshotEvidencePath);
      }
    }
  }

  // â”€â”€â”€ Git: branch, commit, push â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Create branch
  onProgress?.(`Creating branch: ${branchName}`);
  execSync(`git checkout -b "${branchName}"`, { cwd, encoding: 'utf-8', stdio: 'pipe' });

  // 2. Stage fixed files
  onProgress?.('Staging fixed files...');
  for (const change of fix.changes) {
    execSync(`git add "${change.relativePath}"`, { cwd, encoding: 'utf-8', stdio: 'pipe' });
  }

  // Stage evidence files
  if (fs.existsSync(evidenceDir)) {
    execSync('git add evidence/', { cwd, encoding: 'utf-8', stdio: 'pipe' });
  }

  // 3. Commit
  onProgress?.('Committing fix and evidence...');
  const commitMsg = `fix: ${fix.approach}

Root cause: ${fix.explanation}

Verified by automated Playwright test â€” test passed.

Co-Authored-By: Claude AI <noreply@anthropic.com>`;

  const commitMsgFile = path.join(cwd, '.git', 'COMMIT_MSG_TEMP');
  fs.writeFileSync(commitMsgFile, commitMsg, 'utf-8');
  execSync(`git commit -F "${commitMsgFile}"`, { cwd, encoding: 'utf-8', stdio: 'pipe' });
  try { fs.unlinkSync(commitMsgFile); } catch { /* ignore */ }

  // 4. Push branch
  onProgress?.('Pushing branch to GitHub...');
  execSync(`git push -u origin "${branchName}"`, { cwd, encoding: 'utf-8', stdio: 'pipe' });

  // â”€â”€â”€ Upload evidence to GitHub release â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const repoSlug = getRepoSlug(cwd);
  let screenshotUrl = '';
  let gifUrl = '';

  if (repoSlug) {
    const releaseTag = `evidence-${timestamp}`;
    const evidenceFiles = fs.readdirSync(evidenceDir)
      .map(f => path.join(evidenceDir, f))
      .filter(f => fs.statSync(f).isFile());

    if (evidenceFiles.length > 0) {
      onProgress?.('Uploading evidence to GitHub release...');
      try {
        const fileArgs = evidenceFiles.map(f => `"${f}"`).join(' ');
        execSync(
          `gh release create "${releaseTag}" --title "Test Evidence for ${branchName}" --notes "Auto-generated test evidence" ${fileArgs}`,
          { cwd, encoding: 'utf-8', stdio: 'pipe' }
        );

        // Build download URLs for inline rendering
        if (screenshotEvidencePath) {
          screenshotUrl = `https://github.com/${repoSlug}/releases/download/${releaseTag}/test-result-screenshot.png`;
        }
        if (gifPath) {
          gifUrl = `https://github.com/${repoSlug}/releases/download/${releaseTag}/test-verification.gif`;
        }
        onProgress?.('Evidence uploaded to GitHub release');
      } catch {
        onProgress?.('Could not upload evidence release, continuing...');
      }
    }
  }

  // â”€â”€â”€ Build PR body with embedded evidence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  onProgress?.('Creating Pull Request...');
  const diffSummary = fix.changes
    .map(c => `\`${c.relativePath}\``)
    .join(', ');

  const prBodyLines = [
    `## Bug Fix: ${bugDescription}`,
    '',
    '### Root Cause',
    fix.explanation,
    '',
    '### Fix Applied',
    fix.approach,
    '',
    '### Files Changed',
    diffSummary,
    '',
    '### Diff',
    '```diff',
    fix.changes.map(c => c.diff).join('\n'),
    '```',
    '',
    '### Verification',
    '- Playwright test **passed** in real Chromium browser',
    `- ${fix.changes.length} file(s) changed`,
  ];

  if (verification) {
    const duration = (verification.testResult.duration / 1000).toFixed(1);
    prBodyLines.push(`- Test duration: ${duration}s`);

    if (verification.visualReport) {
      prBodyLines.push(`- Visual analysis: ${verification.visualReport.overallAssessment}`);
    }

    if (verification.testResult.videos.length > 0) {
      prBodyLines.push(`- ${verification.testResult.videos.length} video(s) recorded`);
    }
    if (verification.testResult.screenshots.length > 0) {
      prBodyLines.push(`- ${verification.testResult.screenshots.length} screenshot(s) captured`);
    }
  }

  // Add inline evidence images
  if (screenshotUrl || gifUrl) {
    prBodyLines.push('');
    prBodyLines.push('### Evidence');
  }

  if (screenshotUrl) {
    prBodyLines.push('');
    prBodyLines.push('**Test Result Screenshot:**');
    prBodyLines.push(`![Test Screenshot](${screenshotUrl})`);
  }

  if (gifUrl) {
    prBodyLines.push('');
    prBodyLines.push('**Test Recording:**');
    prBodyLines.push(`![Test Recording](${gifUrl})`);
  }

  prBodyLines.push('');
  prBodyLines.push('---');
  prBodyLines.push('*This PR was automatically created by the Bug Fix Verification Agent*');

  const prBody = prBodyLines.join('\n');
  const prBodyFile = path.join(cwd, '.git', 'PR_BODY_TEMP.md');
  fs.writeFileSync(prBodyFile, prBody, 'utf-8');

  // PR title
  const prTitle = `fix: ${fix.approach}`.substring(0, 70);

  // â”€â”€â”€ Create PR via gh CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const prOutput = execSync(
    `gh pr create --title "${prTitle.replace(/"/g, '\\"')}" --body-file "${prBodyFile}"`,
    { cwd, encoding: 'utf-8', stdio: 'pipe' }
  ).trim();

  try { fs.unlinkSync(prBodyFile); } catch { /* ignore */ }

  // Extract PR number from URL
  const prNumberMatch = prOutput.match(/\/pull\/(\d+)/);
  const prNumber = prNumberMatch ? parseInt(prNumberMatch[1]) : 0;

  // â”€â”€â”€ Switch back to main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  onProgress?.('Switching back to main branch...');
  try {
    execSync('git checkout main', { cwd, encoding: 'utf-8', stdio: 'pipe' });
  } catch {
    try {
      execSync('git checkout master', { cwd, encoding: 'utf-8', stdio: 'pipe' });
    } catch { /* stay on current branch */ }
  }

  return {
    prUrl: prOutput,
    prNumber,
    branchName,
  };
}
